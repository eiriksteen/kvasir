"""remove_linked_list_columns_add_position_columns

Revision ID: 99d9dcee541e
Revises: 5e46dedbe986
Create Date: 2025-08-25 15:27:41.024382

"""
from typing import Sequence, Union

from alembic import op
import sqlalchemy as sa
from sqlalchemy.dialects import postgresql

# revision identifiers, used by Alembic.
revision: str = '99d9dcee541e'
down_revision: Union[str, None] = '5e46dedbe986'
branch_labels: Union[str, Sequence[str], None] = None
depends_on: Union[str, Sequence[str], None] = None


def upgrade() -> None:
    # ### commands auto generated by Alembic - please adjust! ###
    op.drop_table('data_object_computed_from_function', schema='pipeline')
    
    # Add position columns as nullable first
    op.add_column('function_in_pipeline', sa.Column('position', sa.Integer(), nullable=True), schema='pipeline')
    op.add_column('function_input', sa.Column('position', sa.Integer(), nullable=True), schema='pipeline')
    op.add_column('function_output', sa.Column('position', sa.Integer(), nullable=True), schema='pipeline')
    
    # Populate position columns based on linked list order
    # For function_in_pipeline, we'll use a simple sequential ordering
    op.execute("""
        WITH ordered_functions AS (
            SELECT id, function_id, pipeline_id, 
                   ROW_NUMBER() OVER (PARTITION BY pipeline_id ORDER BY id) - 1 as pos
            FROM pipeline.function_in_pipeline
        )
        UPDATE pipeline.function_in_pipeline 
        SET position = ordered_functions.pos 
        FROM ordered_functions 
        WHERE pipeline.function_in_pipeline.id = ordered_functions.id
    """)
    
    # For function_input, use sequential ordering per function
    op.execute("""
        WITH ordered_inputs AS (
            SELECT id, function_id, 
                   ROW_NUMBER() OVER (PARTITION BY function_id ORDER BY id) - 1 as pos
            FROM pipeline.function_input
        )
        UPDATE pipeline.function_input 
        SET position = ordered_inputs.pos 
        FROM ordered_inputs 
        WHERE pipeline.function_input.id = ordered_inputs.id
    """)
    
    # For function_output, use sequential ordering per function
    op.execute("""
        WITH ordered_outputs AS (
            SELECT id, function_id, 
                   ROW_NUMBER() OVER (PARTITION BY function_id ORDER BY id) - 1 as pos
            FROM pipeline.function_output
        )
        UPDATE pipeline.function_output 
        SET position = ordered_outputs.pos 
        FROM ordered_outputs 
        WHERE pipeline.function_output.id = ordered_outputs.id
    """)
    
    # Make position columns not null
    op.alter_column('function_in_pipeline', 'position', nullable=False, schema='pipeline')
    op.alter_column('function_input', 'position', nullable=False, schema='pipeline')
    op.alter_column('function_output', 'position', nullable=False, schema='pipeline')
    
    # Remove linked list columns and constraints
    op.drop_constraint('function_in_pipeline_next_function_id_fkey', 'function_in_pipeline', schema='pipeline', type_='foreignkey')
    op.drop_column('function_in_pipeline', 'next_function_id', schema='pipeline')
    op.drop_constraint('function_input_next_function_input_id_fkey', 'function_input', schema='pipeline', type_='foreignkey')
    op.drop_column('function_input', 'next_function_input_id', schema='pipeline')
    op.drop_constraint('function_output_next_function_output_id_fkey', 'function_output', schema='pipeline', type_='foreignkey')
    op.drop_column('function_output', 'next_function_output_id', schema='pipeline')
    # ### end Alembic commands ###


def downgrade() -> None:
    # ### commands auto generated by Alembic - please adjust! ###
    # Add back linked list columns
    op.add_column('function_output', sa.Column('next_function_output_id', sa.UUID(), autoincrement=False, nullable=True), schema='pipeline')
    op.create_foreign_key('function_output_next_function_output_id_fkey', 'function_output', 'function_output', ['next_function_output_id'], ['id'], source_schema='pipeline', referent_schema='pipeline')
    op.drop_column('function_output', 'position', schema='pipeline')
    op.add_column('function_input', sa.Column('next_function_input_id', sa.UUID(), autoincrement=False, nullable=True), schema='pipeline')
    op.create_foreign_key('function_input_next_function_input_id_fkey', 'function_input', 'function_input', ['next_function_input_id'], ['id'], source_schema='pipeline', referent_schema='pipeline')
    op.drop_column('function_input', 'position', schema='pipeline')
    op.add_column('function_in_pipeline', sa.Column('next_function_id', sa.UUID(), autoincrement=False, nullable=True), schema='pipeline')
    op.create_foreign_key('function_in_pipeline_next_function_id_fkey', 'function_in_pipeline', 'function', ['next_function_id'], ['id'], source_schema='pipeline', referent_schema='pipeline')
    op.drop_column('function_in_pipeline', 'position', schema='pipeline')
    op.create_table('data_object_computed_from_function',
    sa.Column('id', sa.UUID(), autoincrement=False, nullable=False),
    sa.Column('data_object_id', sa.UUID(), autoincrement=False, nullable=False),
    sa.Column('function_id', sa.UUID(), autoincrement=False, nullable=False),
    sa.Column('created_at', postgresql.TIMESTAMP(timezone=True), autoincrement=False, nullable=False),
    sa.Column('updated_at', postgresql.TIMESTAMP(timezone=True), autoincrement=False, nullable=False),
    sa.ForeignKeyConstraint(['data_object_id'], ['data_objects.data_object.id'], name='data_object_computed_from_function_data_object_id_fkey'),
    sa.ForeignKeyConstraint(['function_id'], ['pipeline.function.id'], name='data_object_computed_from_function_function_id_fkey'),
    sa.PrimaryKeyConstraint('id', name='data_object_computed_from_function_pkey'),
    schema='pipeline'
    )
    # ### end Alembic commands ###
